import argparse


def lightcone():
    from .. import lightcone
    desc = ("Creates a UniverseMachine lightcone that includes magnitudes "
            " and spectral IDs matched to galaxies in the COSMOS field.")

    # noinspection PyTypeChecker
    parser = argparse.ArgumentParser(description=desc,
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Mandatory positional arguments
    parser.add_argument("Z_LOW", type=float, help="Minimum redshift")
    parser.add_argument("Z_HIGH", type=float, help="Maximum redshift")
    parser.add_argument("X_ARCMIN", type=float, help="Horizontal field "
                                                     "of view sidelength")
    parser.add_argument("Y_ARCMIN", type=float, help="Vertical field "
                                                     "of view sidelength")
    # Optional positional arguments
    parser.add_argument("NUM_SAMPLES", type=int, default=1, nargs="?",
                        help="Number of realizations to create")
    # parser.add_argument("NUM_NEAREST_SPECID", type=int, default=0, nargs="?",
    #                     help="Number of nearest neighbors to match specid's")

    # Argument changing which photometric bands to return
    parser.add_argument("--photbands", type=str, metavar="STRING",
        help="String of characters specifying which magnitude bands to get."
             " Default is GRYJ")

    # Arguments to specify paths
    parser.add_argument("--id-tag", metavar="NAME", help="name the light"
                "cone for easy loading with LightConeConfig(NAME).load(i). "
                "This may not work if outfilepath is specified")
    parser.add_argument("--outfilebase", metavar="NAME", help="base of the "
                "filename to construct the output lightcones")

    parser.add_argument("--executable", metavar="PATH", help="path to the "
                "lightcone executable from the UniverseMachine package")
    parser.add_argument("--umcfg", metavar="PATH", help="path to the "
                "configuration file required by the lightcone executable")
    parser.add_argument("--outfilepath", metavar="PATH", help="directory "
                "to place output files")

    # Specify mass limit / random seed
    parser.add_argument("--obs-mass-limit", type=float, default=8e8,
                    metavar="CUT", help="cut to place on 'obs_sm' column")
    parser.add_argument("--true-mass-limit", type=float, default=0,
                    metavar="CUT", help="cut to place on 'true_sm' column")
    parser.add_argument("--rseed", type=int, metavar="R", help="random "
                                            "seed for this realization")

    # Arguments with not much use
    parser.add_argument("--ra-center", type=float, default=0, metavar="X",
                help="center around this right-ascension")
    parser.add_argument("--dec-center", type=float, default=0, metavar="Y",
                help="center around this declination")
    parser.add_argument("--theta-center", type=float, default=0, metavar="Z",
                help="third rotation angle around ra/dec center")
    parser.add_argument("--do-collision-test", action="store_true",
                        help="not recommended for large lightcones")
    parser.add_argument("--keep-ascii-files", action="store_true",
            help="keep the huge ascii tables generated by UniverseMachine")

    a = parser.parse_args()

    lightcone(a.Z_LOW, a.Z_HIGH, a.X_ARCMIN, a.Y_ARCMIN,
        executable=a.executable, umcfg=a.umcfg, samples=a.NUM_SAMPLES,
        photbands=a.photbands, keep_ascii_files=a.keep_ascii_files,
        obs_mass_limit=a.obs_mass_limit, true_mass_limit=a.true_mass_limit,
        outfilepath=a.outfilepath, outfilebase=a.outfilebase, id_tag=a.id_tag,
        do_collision_test=a.do_collision_test, ra=a.ra_center,
        dec=a.dec_center, theta=a.theta_center, rseed=a.rseed)


def set_data_path():
    import os
    import pathlib
    from .. import mocksurvey as ms

    desc = "Set the path where you would like all the data to be stored"

    # noinspection PyTypeChecker
    parser = argparse.ArgumentParser(description=desc,
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Mandatory positional arguments
    parser.add_argument("DATAPATH", type=str)

    a = parser.parse_args()
    path = os.path.join(a.DATAPATH, "UniverseMachine")
    pathlib.Path(path).mkdir(exist_ok=True)
    ms.UMConfig(path).update()

    path = os.path.join(a.DATAPATH, "UVISTA")
    pathlib.Path(path).mkdir(exist_ok=True)
    ms.UVISTAConfig(path).update()

    path = os.path.join(a.DATAPATH, "SeanSpectra")
    pathlib.Path(path).mkdir(exist_ok=True)
    ms.SeanSpectraConfig(path).update()


def download_um():
    from .. import mocksurvey as ms

    desc = ("Download all UniverseMachine SFR catalogs from peterbehroozi.com "
            "closest to specified redshift (or between a range of redshifts)")

    # noinspection PyTypeChecker
    parser = argparse.ArgumentParser(description=desc,
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Mandatory positional arguments
    parser.add_argument("Z_LOW", type=float, help="Lower redshift bound. If "
                "upper bound not supplied, download closest redshift to Z_LOW")

    # Optional positional arguments
    parser.add_argument("Z_HIGH", type=float, default=None, nargs="?",
                        help="Upper redshift bound to download catalogs")

    a = parser.parse_args()
    redshift = a.Z_LOW if a.Z_HIGH is None else [a.Z_LOW, a.Z_HIGH]

    ms.UMWgetter().download_sfrcat_redshift(redshift)


def download_uvista():
    from .. import mocksurvey as ms

    wgetter = ms.UVISTAWgetter()
    wgetter.download_uvista()
    wgetter.download_seanspectra()


def config():
    from .. import mocksurvey as ms
    datasets = {
        "UM": ms.UMConfig,
        "UVISTA": ms.UVISTAConfig,
        "SeanSpectra": ms.SeanSpectraConfig,
        "LightCone": ms.LightConeConfig,
    }
    cmds = {
        "set-path": None,
        "auto-add": None,
        "reset": None,
        "add": None,
        "remove": None,
        "set-lightcone-executable (UM only)": None,
    }


    desc = ("Configure data storage used by mocksurvey")

    # noinspection PyTypeChecker
    parser = argparse.ArgumentParser(description=desc,
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Mandatory positional arguments
    parser.add_argument("DATASET", type=str, help=f"Options: {set(datasets.keys())}")

    # Optional positional arguments
    parser.add_argument("COMMAND", type=str, default=[], nargs="+",
                        help=f"Options: {set(cmds.keys())}")

    a = parser.parse_args()
    assert len(a.COMMAND) > 0, "Usage: supply a command (and any relevant arguments)"

    config = datasets[a.DATASET]
    if a.COMMAND[0] == "set-path":
        config(*a.COMMAND[1:]).update()

    {
        "auto-add": config().auto_add,
        "reset": config().reset,
        "add": config().add,
        "remove": config().remove,
        "set-lightcone-executable": config().set_lightcone_executable
    }[a.COMMAND[0]](*a.COMMAND[1:])
