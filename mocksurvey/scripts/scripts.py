import argparse

from .. import mocksurvey as ms


class LightCone:
    desc = "Create a UniverseMachine lightcone that includes magnitudes " \
           " and spectral IDs matched to galaxies in the COSMOS field"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument(
            "NAME", type=str, help="Name the light"
            "cone for easy loading with LightConeConfig(NAME).load(i)"
            ". This may not work if outfilepath is specified")
        parser.add_argument("Z_LOW", type=float, help="Minimum redshift")
        parser.add_argument("Z_HIGH", type=float, help="Maximum redshift")
        parser.add_argument("X_ARCMIN", type=float, help="Horizontal field "
                                                         "of view side length")
        parser.add_argument("Y_ARCMIN", type=float, help="Vertical field "
                                                         "of view side length")
        # Optional positional arguments
        parser.add_argument("NUM_SAMPLES", type=int, default=1, nargs="?",
                            help="Number of realizations to create")
        # parser.add_argument("NUM_NEAREST_SPECID", type=int, default=0, nargs="?",
        #                     help="Number of nearest neighbors to match specid's")

        # Option to change which photometric bands to return
        parser.add_argument(
            "--calibration", type=str, metavar="NAME", default="uvista",
            help="String identifier for the dataset with which to "
                 "calibrate photometry into UniverseMachine"
        )
        parser.add_argument(
            "--photbands", type=str, metavar="STRING",
            default="all available",
            help="Comma-separated bands to calculate apparent "
                 "magnitudes by CLIMBER matching to UltraVISTA (or SDSS).")
        parser.add_argument(
            "--fit-with-mass", action="store_true",
            help="Additionally use stellar mass as a predictor for M/L"
        )
        parser.add_argument(
            "--nomags", action="store_true",
            help="Don't calculate sfr_uv or absolute magnitudes"
        )

        # Options to specify paths
        parser.add_argument(
            "--outfilebase", metavar="NAME", help="Base of the "
            "filename to construct the output lightcones")
        parser.add_argument(
            "--outfilepath", metavar="PATH", help="Directory "
            "to place output files")
        parser.add_argument(
            "--executable", metavar="PATH", help="Path to the "
            "lightcone executable from the UniverseMachine library")
        parser.add_argument(
            "--umcfg", metavar="PATH", help="Path to the "
            "configuration file required by the lightcone executable")

        # Options to specify mass limit / random seed
        parser.add_argument(
            "--obs-mass-limit", type=float, default=8e8,
            metavar="CUT", help="Cut to place on 'obs_sm' column")
        parser.add_argument(
            "--true-mass-limit", type=float, default=0,
            metavar="CUT", help="Cut to place on 'true_sm' column")
        parser.add_argument("--rseed", type=int, metavar="SEED",
                            help="Random seed for this realization")

        # Options for the random forest calibration
        parser.add_argument(
            "--rf-params", type=str, metavar="OPTION", default="original",
            help="Random forest hyperparameters. Options: optimized | original"
        )
        parser.add_argument(
            "--n-estimators", type=int, metavar="N", default=None,
            help="Number of trees in the random forest"
        )

        # Options with not much use
        parser.add_argument(
            "--ra-center", type=float, default=0, metavar="X",
            help="Center around this right-ascension")
        parser.add_argument(
            "--dec-center", type=float, default=0, metavar="Y",
            help="Center around this declination")
        parser.add_argument(
            "--theta-center", type=float, default=0, metavar="Z",
            help="Third rotation angle around ra/dec center")
        parser.add_argument("--do-collision-test", action="store_true",
                            help="Not recommended for large lightcones")
        parser.add_argument(
            "--keep-ascii-files", action="store_true",
            help="Keep the huge ascii tables generated by UniverseMachine")
        parser.add_argument(
            "--start-from-ascii", action="store_true",
            help="Don't generate new lightcones. Use preexisting ascii "
            "files in the location they are expected")

    def __call__(self):
        a = self.parser.parse_args()
        if "," in a.photbands:
            a.photbands = a.photbands.split(",")
            a.photbands = [x for s in a.photbands if (x := s.strip())]
        elif a.photbands == "all available":
            a.photbands = None
        else:
            raise ValueError("--photbands must receive a comma-separated "
                             "list of bands (e.g., 'g,r,i,z,y,h,j,k,ch1,ch2')")
        ms.climber.lightcone(a.Z_LOW, a.Z_HIGH, a.X_ARCMIN, a.Y_ARCMIN, executable=a.executable, umcfg=a.umcfg,
                             samples=a.NUM_SAMPLES, calibration=a.calibration, photbands=a.photbands,
                             fit_with_mass=a.fit_with_mass, nomags=a.nomags,
                             obs_mass_limit=a.obs_mass_limit, true_mass_limit=a.true_mass_limit,
                             outfilepath=a.outfilepath, id_tag=a.NAME, do_collision_test=a.do_collision_test,
                             ra=a.ra_center, dec=a.dec_center, theta=a.theta_center, rseed=a.rseed,
                             keep_ascii_files=a.keep_ascii_files, start_from_ascii=a.start_from_ascii,
                             rf_params=a.rf_params, n_estimators=a.n_estimators)


class LightConeSelection:
    desc = "Create a new lightcone from a subset of an existing one " \
           "by performing a selection function"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument(
            "INPUT_NAME", type=str, help="Name of the input lightcone")
        parser.add_argument(
            "OUTPUT_NAME", type=str, help="Name of the output lightcone")
        parser.add_argument(
            "Z_LOW", type=float, help="Minimum velocity-distorted redshift")
        parser.add_argument(
            "Z_HIGH", type=float, help="Maximum velocity-distorted redshift")

        # Optional positional argument
        parser.add_argument(
            "SQDEG", type=float, help="Size of the field in square degrees. "
                                      "Full sky by default", nargs="?")

        # Options to modify the selection function
        parser.add_argument(
            "--field-shape", type=str, default="square", metavar="SHAPE",
            help="Shape of the selection area on the sky")
        parser.add_argument(
            "--max", action="append", nargs=2, metavar=("KEY", "VALUE"),
            type=DictItem(float),
            help="Remove galaxies with higher than VALUE of KEY")
        parser.add_argument(
            "--min", action="append", nargs=2, metavar=("KEY", "VALUE"),
            type=DictItem(float),
            help="Remove galaxies with lower than VALUE of KEY")
        parser.add_argument(
            "--sample-fraction", type=float, default=1.0, metavar="FRAC",
            help="Fraction to randomly select")

        # Option to specify input lightcones
        parser.add_argument(
            "--realization", metavar="I,J,K,...",
            type=lambda x: [int(i) for i in x.split(",")],
            help="Comma-separated indices of realizations of input lightcone. "
                 "Perform selection on all realizations by default")

        # Option to specify output lightcone
        parser.add_argument(
            "--nblocks-per-dim", type=int, default=1, metavar="N",
            help="Split into N^2 equal-sized regions of the sky")
        parser.add_argument(
            "--outfile", type=str, metavar="NAME",
            help="Base of the filename of the new lightcone")

    def __call__(self):
        a = self.parser.parse_args()
        if a.max is not None:
            a.max = dict(a.max)
        if a.min is not None:
            a.min = dict(a.min)
        selector = ms.LightConeSelector(a.Z_LOW, a.Z_HIGH, a.SQDEG,
                                        a.field_shape, a.sample_fraction,
                                        a.min, a.max)
        ms.climber.lightcone_selection(a.INPUT_NAME, a.OUTPUT_NAME, selector,
                                       outfile=a.outfile,
                                       input_realization=a.realization,
                                       nblocks_per_dim=a.nblocks_per_dim)


class RecalibrateLightCone:
    desc = "Create a new lightcone from an existing one, " \
           "but replacing photometry columns with recalibrated ones"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument(
            "INPUT_NAME", type=str, help="Name of the input lightcone")
        parser.add_argument(
            "OUTPUT_NAME", type=str, help="Name of the output lightcone")

        # Calibration options
        parser.add_argument(
            "--calibration", type=str, metavar="NAME", default="uvista",
            help="String identifier for the dataset with which to "
                 "calibrate photometry into UniverseMachine"
        )
        parser.add_argument(
            "--keep-old", action="store_true",
            help="Don't delete the old photometry columns. Rename them m_*_old"
        )
        parser.add_argument(
            "--rf-params", type=str, metavar="OPTION", default="original",
            help="Random forest hyperparameters. Options: optimized | original"
        )
        parser.add_argument(
            "--n-estimators", type=int, metavar="N", default=None,
            help="Number of trees in the random forest"
        )

        # Option to specify input lightcones
        parser.add_argument(
            "--realization", metavar="I,J,K,...",
            type=lambda x: [int(i) for i in x.split(",")],
            help="Comma-separated indices of realizations of input lightcone. "
                 "Perform selection on all realizations by default")

        # Option to specify output lightcone
        parser.add_argument(
            "--outfile", type=str, metavar="NAME",
            help="Base of the filename of the new lightcone")

    def __call__(self):
        a = self.parser.parse_args()
        ms.climber.recalibrate_lightcone(a.INPUT_NAME, a.OUTPUT_NAME,
                                         calibration=a.calibration,
                                         rf_params=a.rf_params,
                                         n_estimators=a.n_estimators,
                                         outfile=a.outfile, keep_old=a.keep_old,
                                         input_realization=a.realization)


class LightConeSpectra:
    desc = "Assign spectra to each mock galaxy in a lightcone by " \
           "nearest-neighbor matching to UltraVISTA galaxies"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional argument
        parser.add_argument(
            "INPUT_NAME", type=str, help="Name of the input lightcone")

        # Option to include raw spectra in the ouput
        parser.add_argument(
            "--make-specmap", "-s", action="store_true",
            help="Include large data cubes of raw spectra for the whole mock")

        # Option to specify input lightcones
        parser.add_argument(
            "--realization", metavar="I,J,K,...",
            type=lambda x: [int(i) for i in x.split(",")],
            help="Comma-separated indices of realizations of input lightcone. "
                 "Perform selection on all realizations by default")

        # Options to modify nearest-neighbor algorithm
        parser.add_argument(
            "--photbands", type=str, metavar="STRING", default="GRYJ",
            help="String of photometric bands to use in neighbor-matching")
        parser.add_argument(
            "--best-of", type=int, metavar="N", default=6,
            help="Number of nearest neighbors in mass,sSFR,z-space from "
                 "which to choose the nearest neighbor in color-space")
        parser.add_argument(
            "--use-meng-specs", action="store_true",
            help="Replace Sean's spectra with Meng's updated library")

    def __call__(self):
        a = self.parser.parse_args()
        ms.climber.lightcone_spectra(a.INPUT_NAME, a.realization,
                                     make_specmap=a.make_specmap,
                                     best_of=a.best_of,
                                     photbands=a.photbands,
                                     use_meng_specs=a.use_meng_specs)


class SetDataPath:
    desc = "Set the path where you would like all the data to be stored"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument("DATAPATH", type=str)

    def __call__(self):
        import os
        import pathlib

        a = self.parser.parse_args()

        path = os.path.join(a.DATAPATH, "UniverseMachine")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.UMConfig(path).auto_add()

        path = os.path.join(a.DATAPATH, "SDSS")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.UVISTAConfig(path).auto_add()

        path = os.path.join(a.DATAPATH, "UVISTA")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.UVISTAConfig(path).auto_add()

        path = os.path.join(a.DATAPATH, "SeanSpectra")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.SeanSpectraConfig(path).auto_add()

        path = os.path.join(a.DATAPATH, "MengSpectra")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.MengSpectraConfig(path).auto_add()


class DownloadUM:
    desc = ("Download all UniverseMachine SFR catalogs from peterbehroozi.com"
            " closest to specified redshift (or between a range of redshifts)")

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument(
            "Z_LOW", type=float, help="Lower redshift bound. If "
            "upper bound not supplied, download closest redshift to Z_LOW")

        # Optional positional arguments
        parser.add_argument("Z_HIGH", type=float, default=None, nargs="?",
                            help="Upper redshift bound to download catalogs")

        # Options
        # parser.add_argument("--verbose", "-v", action="store_true")
        parser.add_argument("--overwrite", "-o", action="store_true")

    def __call__(self):
        a = self.parser.parse_args()

        redshift = a.Z_LOW if a.Z_HIGH is None else [a.Z_LOW, a.Z_HIGH]
        ms.UMWgetter().download_sfrcat_redshift(
            redshift, overwrite=a.overwrite)


# TODO
# class DownloadSDSS:
#     desc = "Downloads all data required by " \
#            "mocksurvey for calibration to SDSS"
#
#     def __init__(self, parser):
#         self.parser = parser
#         parser.description = self.desc
#         parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter
#
#         # Options
#         # parser.add_argument("--verbose", "-v", action="store_true")
#         parser.add_argument("--overwrite", "-o", action="store_true")
#
#     def __call__(self):
#         a = self.parser.parse_args()
#
#         # TODO: Write SDSSWgetter analogously to UVISTAWgetter
#         wgetter = ms.SDSSWgetter()
#         wgetter.download_sdss(overwrite=a.overwrite)


class DownloadUVISTA:
    desc = "Downloads all data required by " \
           "mocksurvey for calibration to UltraVISTA"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Options
        # parser.add_argument("--verbose", "-v", action="store_true")
        parser.add_argument("--overwrite", "-o", action="store_true")

    def __call__(self):
        a = self.parser.parse_args()

        wgetter = ms.UVISTAWgetter()
        wgetter.download_uvista(overwrite=a.overwrite)
        wgetter.download_sean_specprops(overwrite=a.overwrite)


class DownloadUVISTAMockSpectra:
    desc = "Download the raw spectra needed " \
           "for assigning to nearest-neighbors in the mock"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Options
        # parser.add_argument("--verbose", "-v", action="store_true")
        parser.add_argument("--overwrite", "-o", action="store_true")

    def __call__(self):
        a = self.parser.parse_args()

        wgetter = ms.UVISTAWgetter()
        wgetter.download_sean_specmap(overwrite=a.overwrite)


class Config:  # TODO: write list-all-configs and delete-directory command
    desc = "Configure data storage used by mocksurvey"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        self.datasets = {
            "UM": ms.UMConfig,
            "SDSS": ms.SDSSConfig,
            "UVISTA": ms.UVISTAConfig,
            "SeanSpectra": ms.SeanSpectraConfig,
            "LightCone": ms.LightConeConfig,
        }
        self.cmds = {
            "set-path": None,
            "auto-add": None,
            "delete": None,
            "add-file": None,
            "remove-file": None,
            "set-lightcone-executable (UM only)": None,
        }

        # Mandatory positional arguments
        parser.add_argument("DATASET", type=str,
                            help=f"Options: {set(self.datasets.keys())}")
        parser.add_argument("COMMAND", type=str,
                            help=f"Options: {set(self.cmds.keys())}")

        # Optional positional arguments
        parser.add_argument("ARGS", type=str, default=[], nargs="*",
                            help="Positional arguments for COMMAND")

    def __call__(self):
        a = self.parser.parse_args()
        if a.DATASET == "LightCone" or a.COMMAND == "set-path":
            args1, args2 = a.ARGS[:1], a.ARGS[1:]
        else:
            args1, args2 = [], a.ARGS

        command = {
            "set-path": "save",
            "auto-add": "auto_add",
            "delete": "delete",
            "add-file": "add_file",
            "remove-file": "remove_file",
            "set-lightcone-executable": "set_lightcone_executable"
        }[a.COMMAND]

        config = self.datasets[a.DATASET](*args1)
        getattr(config, command)(*args2)
        config.save()


class DictItem:
    def __init__(self, valuetype=float):
        self._is_value = True
        self.valuetype = valuetype

    def __call__(self, x):
        self._is_value = not self._is_value
        if self._is_value:
            return self.valuetype(x)
        else:
            return str(x)
