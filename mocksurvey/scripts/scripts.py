import argparse
from .. import mocksurvey as ms


class LightCone:
    desc = ("Creates a UniverseMachine lightcone that includes magnitudes "
            " and spectral IDs matched to galaxies in the COSMOS field.")

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument(
                    "NAME", type=str, help="name the light"
                    "cone for easy loading with LightConeConfig(NAME).load(i)"
                    ". This may not work if outfilepath is specified")
        parser.add_argument("Z_LOW", type=float, help="Minimum redshift")
        parser.add_argument("Z_HIGH", type=float, help="Maximum redshift")
        parser.add_argument("X_ARCMIN", type=float, help="Horizontal field "
                                                         "of view side length")
        parser.add_argument("Y_ARCMIN", type=float, help="Vertical field "
                                                         "of view side length")
        # Optional positional arguments
        parser.add_argument("NUM_SAMPLES", type=int, default=1, nargs="?",
                            help="Number of realizations to create")
        # parser.add_argument("NUM_NEAREST_SPECID", type=int, default=0, nargs="?",
        #                     help="Number of nearest neighbors to match specid's")

        # Argument changing which photometric bands to return
        parser.add_argument(
            "--photbands", type=str, metavar="STRING", default="UBVGRIZYJHK",
            help="String of photometric bands to calculate apparent "
                 "magnitudes by abundance-matching to UltraVISTA. "
                 "Use all available bands by default")

        # Arguments to specify paths
        parser.add_argument(
                    "--outfilebase", metavar="NAME", help="base of the "
                    "filename to construct the output lightcones")
        parser.add_argument(
                    "--outfilepath", metavar="PATH", help="directory "
                    "to place output files")
        parser.add_argument(
                    "--executable", metavar="PATH", help="path to the "
                    "lightcone executable from the UniverseMachine package")
        parser.add_argument(
                    "--umcfg", metavar="PATH", help="path to the "
                    "configuration file required by the lightcone executable")

        # Specify mass limit / random seed
        parser.add_argument(
                        "--obs-mass-limit", type=float, default=8e8,
                        metavar="CUT", help="cut to place on 'obs_sm' column")
        parser.add_argument(
                        "--true-mass-limit", type=float, default=0,
                        metavar="CUT", help="cut to place on 'true_sm' column")
        parser.add_argument("--rseed", type=int, metavar="SEED",
                            help="random seed for this realization")

        # Arguments with not much use
        parser.add_argument(
                    "--ra-center", type=float, default=0, metavar="X",
                    help="center around this right-ascension")
        parser.add_argument(
                    "--dec-center", type=float, default=0, metavar="Y",
                    help="center around this declination")
        parser.add_argument(
                    "--theta-center", type=float, default=0, metavar="Z",
                    help="third rotation angle around ra/dec center")
        parser.add_argument("--do-collision-test", action="store_true",
                            help="not recommended for large lightcones")
        parser.add_argument(
                "--keep-ascii-files", action="store_true",
                help="keep the huge ascii tables generated by UniverseMachine")

    def __call__(self):
        a = self.parser.parse_args()
        if "," in a.photbands:
            a.photbands = a.photbands.split(",")
            a.photbands = [s.strip() for s in a.photbands if s]
        ms.ummags.lightcone(
            a.Z_LOW, a.Z_HIGH, a.X_ARCMIN, a.Y_ARCMIN,
            executable=a.executable, umcfg=a.umcfg, samples=a.NUM_SAMPLES,
            photbands=a.photbands, keep_ascii_files=a.keep_ascii_files,
            obs_mass_limit=a.obs_mass_limit, true_mass_limit=a.true_mass_limit,
            outfilepath=a.outfilepath, id_tag=a.NAME,
            do_collision_test=a.do_collision_test, ra=a.ra_center,
            dec=a.dec_center, theta=a.theta_center, rseed=a.rseed)


class SetDataPath:
    desc = "Set the path where you would like all the data to be stored"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument("DATAPATH", type=str)

    def __call__(self):
        import os
        import pathlib

        a = self.parser.parse_args()

        path = os.path.join(a.DATAPATH, "UniverseMachine")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.UMConfig(path).auto_add()

        path = os.path.join(a.DATAPATH, "UVISTA")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.UVISTAConfig(path).auto_add()

        path = os.path.join(a.DATAPATH, "SeanSpectra")
        pathlib.Path(path).mkdir(exist_ok=True)
        ms.SeanSpectraConfig(path).auto_add()


class DownloadUM:
    desc = ("Download all UniverseMachine SFR catalogs from peterbehroozi.com "
            "closest to specified redshift (or between a range of redshifts)")

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Mandatory positional arguments
        parser.add_argument(
                    "Z_LOW", type=float, help="Lower redshift bound. If "
                    "upper bound not supplied, download closest redshift to Z_LOW")

        # Optional positional arguments
        parser.add_argument("Z_HIGH", type=float, default=None, nargs="?",
                            help="Upper redshift bound to download catalogs")

        # Options
        # parser.add_argument("--verbose", "-v", action="store_true")
        parser.add_argument("--overwrite", "-o", action="store_true")

    def __call__(self):
        a = self.parser.parse_args()

        redshift = a.Z_LOW if a.Z_HIGH is None else [a.Z_LOW, a.Z_HIGH]
        ms.UMWgetter().download_sfrcat_redshift(
            redshift, overwrite=a.overwrite)


class DownloadUVISTA:
    desc = "This script downloads all data required by " \
           "mocksurvey for fitting to UltraVISTA"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        # Options
        # parser.add_argument("--verbose", "-v", action="store_true")
        parser.add_argument("--overwrite", "-o", action="store_true")

    def __call__(self):
        a = self.parser.parse_args()

        wgetter = ms.UVISTAWgetter()
        wgetter.download_uvista(overwrite=a.overwrite)
        wgetter.download_sean_specprops(overwrite=a.overwrite)


class Config:
    desc = "Configure data storage used by mocksurvey"

    def __init__(self, parser):
        self.parser = parser
        parser.description = self.desc
        parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter

        self.datasets = {
            "UM": ms.UMConfig,
            "UVISTA": ms.UVISTAConfig,
            "SeanSpectra": ms.SeanSpectraConfig,
            "LightCone": ms.LightConeConfig,
        }
        self.cmds = {
            "set-path": None,
            "auto-add": None,
            "delete": None,
            "add-file": None,
            "remove-file": None,
            "set-lightcone-executable (UM only)": None,
        }

        # Mandatory positional arguments
        parser.add_argument("DATASET", type=str,
                            help=f"Options: {set(self.datasets.keys())}")
        parser.add_argument("COMMAND", type=str,
                            help=f"Options: {set(self.cmds.keys())}")

        # Optional positional arguments
        parser.add_argument("ARGS", type=str, default=[], nargs="*",
                            help="Positional arguments for COMMAND")

    def __call__(self):
        a = self.parser.parse_args()
        if a.DATASET == "LightCone" or a.COMMAND == "set-path":
            args1, args2 = a.ARGS[:1], a.ARGS[1:]
        else:
            args1, args2 = [], a.ARGS

        config = self.datasets[a.DATASET](*args1)
        {
            "set-path": getattr(config, "save"),
            "auto-add": getattr(config, "auto_add"),
            "delete": getattr(config, "delete"),
            "add-file": getattr(config, "add_file"),
            "remove-file": getattr(config, "remove_file"),
            "set-lightcone-executable": getattr(
                config, "set_lightcone_executable",
                raise_lightcone_executable_error
            )
        }[a.COMMAND](*args2)
        config.save()


# noinspection PyUnusedLocal
def raise_lightcone_executable_error(*args):
    raise ValueError("set-lightcone-executable only valid COMMAND"
                     "if DATASET = UM")
